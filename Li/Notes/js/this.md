# What is `this?` 

> 想要找到this真正的指向，你首先要知道this的真正调用位置，我们现在假设你已经成功地锁定了this的调用位置，那么你就可以按照这篇tip来确定this的真正指向

* 默认绑定：

  无法应用其余绑定规则时应用默认绑定，this指向全局对象（严格模式下指向undefined）

* 隐式绑定：

  假如你写出了这样的代码：`obj.function();`，那么你的`function`中的`this`将会指向`obj`,因此我们说，如果函数调用时引用有上下文对象，那么函数的`this`将会指向其引用的上下文对象，如有多个，取栈顶那个：`obj.obj1.function`指向`obj1`。

  ***

  但是需要特别注意的是，应用隐式绑定规则时，必须要在引用同时调用才能有效果。比如上例。如果你写成下面的代码：`var foo = obj.function;foo();`，可以肯定，你所做的是无用功，因为函数在执行时只关注你的函数内容和执行上下文。所以`foo`中的`this`指向全局（严格模式undefined），通常我们把这种现象称作**隐式丢失**

* 显式绑定：

  通常情况下利用`call`,`apply`函数能达到与上相同的效果:

  `foo.call(obj1)`

  `foo.apply(obj1)`

  这样操作能使`foo`的`this`绑定在既定对象上，假如你传入的不是对象而是原始值（字符串，布尔，数字），那么他将会被转换成对象形式（new String(),new Boolean(),new Number()）

  ***

  显式绑定可以解决上面所说的隐式丢失问题。解决问题的关键在`var some = function() {return foo.call(obj)}`，这样，以后调用some函数就相当于调用绑定了`obj`的`foo`函数了，基于这个机制，ES5中设置了`bind`函数来帮助我们实现硬绑定的功能。

* new绑定

  js没有构造函数，只有对于函数的构造调用。与其他的面向对象语言构造函数完全不同，使用new操作符创建的对象并不会属于某个类。使用new来调用函数时会构造一个新的对象并把它绑定到函数调用的`this`上

  ```
  function foo(a){
    this.a = a;
  }
  var bar = new foo(2);
  console.log(bar.a); //2
  ```

  待扩充。。。

---

> 谈完了this，不得不谈的是ES6的箭头函数，箭头函数根据外层的（函数或者全局）作用域来决定this，相当于经常使用的self=this之类的语句。一经绑定无法修改。假如你熟悉ES6语法，大可以抛弃this语法，转而使用箭头函数。要注意，两种风格并存是一件令人头疼的事情。